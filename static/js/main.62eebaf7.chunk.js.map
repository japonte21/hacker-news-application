{"version":3,"sources":["selectors/story.js","components/Button.js","components/Story.js","actions/archive.js","constants/actionTypes.js","components/Stories.js","components/SearchStories.js","actions/story.js","components/App.js","reducers/story.js","reducers/archive.js","reducers/index.js","api/story.js","sagas/story.js","sagas/index.js","store/index.js","serviceWorker.js","index.js"],"names":["getReadableStories","archivedIds","storyState","archiveState","stories","filter","story","indexOf","objectID","ButtonInline","onClick","type","children","className","Button","connect","dispatch","onArchive","id","doArchiveStory","columns","title","url","author","num_comments","points","style","width","href","comments","archive","COLUMNS","label","StoriesHeader","Object","keys","map","key","state","error","SearchStories","props","onChange","bind","onSubmit","query","event","this","onFetchStories","setState","preventDefault","value","target","React","Component","doFetchStories","App","display","justifyContent","alignItems","fontStyle","INITIAL_STATE","applyAddStories","action","applyFetchErrorStories","storyReducer","applyArchiveStory","archiveReducer","rootReducer","combineReducers","fetchStories","fetch","then","response","json","handleFetchStories","call","result","put","hits","watchAll","all","takeEvery","logger","createLogger","saga","createSagaMiddleware","store","createStore","undefined","applyMiddleware","run","rootSaga","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","console","message"],"mappings":"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","file":"static/js/main.62eebaf7.chunk.js","sourcesContent":["const isNotArchived = (archivedIds) => (story) =>\n  archivedIds.indexOf(story.objectID) === -1;\n\nconst getReadableStories = ({ storyState, archiveState }) =>\n  storyState.stories.filter(isNotArchived(archiveState));\n\nconst getFetchError = ({ storyState }) => storyState.error;\n\nexport { getReadableStories, getFetchError };\n","import React from \"react\";\n\nconst ButtonInline = ({ onClick, type = \"button\", children }) => (\n  <Button type={type} className=\"button-inline\" onClick={onClick}>\n    {children}\n  </Button>\n);\n\nconst Button = ({ onClick, className, type = \"button\", children }) => (\n  <button type={type} className={className} onClick={onClick}>\n    {children}\n  </button>\n);\n\nexport default Button;\n\nexport { ButtonInline };\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { doArchiveStory } from \"../actions/archive\";\nimport { ButtonInline } from \"./Button\";\nimport \"./Story.css\";\n\nconst Story = ({ story, columns, onArchive }) => {\n  const { title, url, author, num_comments, points, objectID } = story;\n\n  return (\n    <div className=\"story\">\n      <span style={{ width: columns.title.width }}>\n        <a href={url}>{title}</a>\n      </span>\n      <span style={{ width: columns.author.width }}>{author}</span>\n      <span style={{ width: columns.comments.width }}>{num_comments}</span>\n      <span style={{ width: columns.points.width }}>{points}</span>\n      <span style={{ width: columns.archive.width }}>\n        <ButtonInline onClick={() => onArchive(objectID)}>Archive</ButtonInline>\n      </span>\n    </div>\n  );\n};\n\nconst mapDispatchToProps = (dispatch) => ({\n  onArchive: (id) => dispatch(doArchiveStory(id)),\n});\n\nexport default connect(null, mapDispatchToProps)(Story);\n","import { STORY_ARCHIVE } from \"../constants/actionTypes\";\n\nconst doArchiveStory = (id) => ({\n  type: STORY_ARCHIVE,\n  id,\n});\n\nexport { doArchiveStory };\n","export const STORY_ARCHIVE = 'STORY_ARCHIVE';\nexport const STORIES_FETCH = 'STORIES_FETCH';\nexport const STORIES_FETCH_ERROR = 'STORIES_FETCH_ERROR';\nexport const STORIES_ADD = 'STORIES_ADD';\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { getReadableStories, getFetchError } from \"../selectors/story\";\nimport \"./Stories.css\";\n\nimport Story from \"./Story\";\n\nconst COLUMNS = {\n  title: {\n    label: \"Title\",\n    width: \"40%\",\n  },\n  author: {\n    label: \"Author\",\n    width: \"30%\",\n  },\n  comments: {\n    label: \"Comments\",\n    width: \"10%\",\n  },\n  points: {\n    label: \"Points\",\n    width: \"10%\",\n  },\n  archive: {\n    width: \"10%\",\n  },\n};\n\nconst Stories = ({ stories, error }) => (\n  <div className=\"stories\">\n    <StoriesHeader columns={COLUMNS} />\n\n    {error && <p className=\"error\">Something went wrong ...</p>}\n\n    {(stories || []).map((story) => (\n      <Story key={story.objectID} story={story} columns={COLUMNS} />\n    ))}\n  </div>\n);\n\nconst StoriesHeader = ({ columns }) => (\n  <div className=\"stories-header\">\n    {Object.keys(columns).map((key) => (\n      <span key={key} style={{ width: columns[key].width }}>\n        {columns[key].label}\n      </span>\n    ))}\n  </div>\n);\n\nconst mapStateToProps = (state) => ({\n  stories: getReadableStories(state),\n  error: getFetchError(state),\n});\n\nexport default connect(mapStateToProps)(Stories);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { doFetchStories } from \"../actions/story\";\nimport Button from \"./Button\";\n\nconst applyQueryState = (query) => () => ({\n  query,\n});\n\nclass SearchStories extends React.Component {\n  constructor(props) {\n    super(props);\n      this.onChange = this.onChange.bind(this);\n      this.onSubmit = this.onSubmit.bind(this);\n    this.state = {\n      query: \"\",\n    };\n  }\n\n  onSubmit(event) {\n    const { query } = this.state;\n    if (query) {\n      this.props.onFetchStories(query);\n        this.setState({ query: \"\" });\n    }\n\n    event.preventDefault();\n  }\n\n  onChange(event) {\n    const { value } = event.target;\n    this.setState({ query: value });\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.onSubmit}>\n        <input type=\"text\" value={this.state.query} onChange={this.onChange} />\n        <Button type=\"submit\">Search</Button>\n      </form>\n    );\n  }\n}\n\nconst mapDispatchToProps = (dispatch) => ({\n  onFetchStories: (query) => dispatch(doFetchStories(query)),\n});\n\nexport default connect(null, mapDispatchToProps)(SearchStories);\n","import {\n  STORIES_ADD,\n  STORIES_FETCH,\n  STORIES_FETCH_ERROR,\n} from \"../constants/actionTypes\";\n\nconst doAddStories = (stories) => ({\n  type: STORIES_ADD,\n  stories,\n});\n\nconst doFetchStories = (query) => ({\n  type: STORIES_FETCH,\n  query,\n});\n\nconst doFetchErrorStories = (error) => ({\n  type: STORIES_FETCH_ERROR,\n  error,\n});\n\nexport { doAddStories, doFetchStories, doFetchErrorStories };\n","import React from \"react\";\nimport \"./App.css\";\n\nimport Stories from \"./Stories\";\nimport SearchStories from \"./SearchStories\";\n\nconst App = () => (\n  <div className=\"app\">\n    <div\n      style={{\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        fontStyle: \"italic\",\n      }}\n    >\n      Search a topic to get stories shared on Hacker News\n    </div>\n    &nbsp;\n    <div className=\"interactions\">\n      <SearchStories />\n    </div>\n    <Stories />\n  </div>\n);\n\nexport default App;\n","import { STORIES_ADD, STORIES_FETCH_ERROR } from \"../constants/actionTypes\";\n\nconst INITIAL_STATE = {\n  stories: [],\n  error: null,\n};\n\nconst applyAddStories = (state, action) => ({\n  stories: action.stories,\n  error: null,\n});\n\nconst applyFetchErrorStories = (state, action) => ({\n  stories: [],\n  error: action.error,\n});\n\nfunction storyReducer(state = INITIAL_STATE, action) {\n  switch (action.type) {\n    case STORIES_ADD: {\n      return applyAddStories(state, action);\n    }\n    case STORIES_FETCH_ERROR: {\n      return applyFetchErrorStories(state, action);\n    }\n    default:\n      return state;\n  }\n}\n\nexport default storyReducer;\n","import { STORY_ARCHIVE } from \"../constants/actionTypes\";\n\nconst INITIAL_STATE = [];\n\nconst applyArchiveStory = (state, action) =>\n    [...state, action.id];\n\nfunction archiveReducer(state = INITIAL_STATE, action) {\n  switch (action.type) {\n    case STORY_ARCHIVE: {\n      return applyArchiveStory(state, action);\n    }\n    default: return state;\n  }\n}\n\nexport default archiveReducer;\n","import { combineReducers } from \"redux\";\nimport storyReducer from \"./story\";\nimport archiveReducer from \"./archive\";\n\nconst rootReducer = combineReducers({\n  storyState: storyReducer,\n  archiveState: archiveReducer,\n});\n\nexport default rootReducer;\n","const HN_BASE_URL = \"https://hn.algolia.com/api/v1/search?query=\";\n\nconst fetchStories = (query) =>\n  fetch(HN_BASE_URL + query).then((response) => response.json());\n\nexport { fetchStories };\n\n","import { call, put } from \"redux-saga/effects\";\nimport { doAddStories, doFetchErrorStories } from \"../actions/story\";\nimport { fetchStories } from \"../api/story\";\n\nfunction* handleFetchStories(action) {\n  const { query } = action;\n\n  try {\n    const result = yield call(fetchStories, query);\n    yield put(doAddStories(result.hits));\n  } catch (error) {\n    yield put(doFetchErrorStories(error));\n  }\n}\n\nexport { handleFetchStories };\n","import { takeEvery, all } from \"redux-saga/effects\";\nimport { STORIES_FETCH } from \"../constants/actionTypes\";\nimport { handleFetchStories } from \"./story\";\n\nfunction* watchAll() {\n  yield all([takeEvery(STORIES_FETCH, handleFetchStories)]);\n}\n\nexport default watchAll;\n","import { createStore, applyMiddleware } from \"redux\";\nimport { createLogger } from \"redux-logger\";\nimport createSagaMiddleware from \"redux-saga\";\nimport rootReducer from \"../reducers\";\nimport rootSaga from \"../sagas\";\n\nconst logger = createLogger();\nconst saga = createSagaMiddleware();\n\nconst store = createStore(\n  rootReducer,\n  undefined,\n  applyMiddleware(saga, logger)\n);\n\nsaga.run(rootSaga);\n\nexport default store;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Provider } from \"react-redux\";\nimport App from \"./components/App\";\nimport store from \"./store\";\nimport \"./index.css\";\nimport * as serviceWorker from \"./serviceWorker\";\n//import { HashRouter, Route, Switch } from \"react-router-dom\";\n\nReactDOM.render(\n//  <HashRouter basename={process.env.PUBLIC_URL}>\n    <Provider store={store}>\n      <App />\n    </Provider>,\n//  </HashRouter>,\n  document.getElementById(\"root\")\n);\n\nserviceWorker.unregister();\n"],"sourceRoot":""}